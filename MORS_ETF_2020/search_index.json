[
["index.html", "Git and Differential Equations in R 1 Class Introduction 1.1 Topics &amp; Class Structure 1.2 Software Prerequisites 1.3 Human Prerequisites 1.4 Distance Learning Challenges 1.5 Endstate 1.6 Instructors Introduction 1.7 Lets Get Started…", " Git and Differential Equations in R MAJ Dusty Turner and Robert Ward 7 DEC 2020 1 Class Introduction Disclaimer: The appearance of U.S. Department of Defense (DoD) visual information does not imply or constitute DoD endorsement. The views expressed in this presentation are those only of the author and do not represent the official position of the U.S. Army, DoD, or the federal government. 1.1 Topics &amp; Class Structure Git/GitHub setup and repository download (~45 minutes; interactive) Ten-minute break Using R for modeling with differential equations (~30 minutes; interactive) Collaboration using Git (as time allows; instructor demonstration) 1.2 Software Prerequisites R 3.6.x or newer RStudio 1.2.x or newer Git Git Bash (included with Git for Windows) or another command-line application of your choice capable of using Git A github account github website 1.3 Human Prerequisites We assume you have: Working knowledge of R and RStudio; Some experience with contemporary tidy coding concepts; A need to work collaboratively on projects; A healthy appreciation of dad jokes. Try to follow along, at least through the differential equation section. It’s okay to struggle to keep up with certain parts of this - we’ll do our best to help you, but we also won’t be offended if you decide to leave. 1.4 Distance Learning Challenges Don’t be afraid to ask questions - both verbally and in chat. If you miss something we said, it’s likely others have too - you’ll be helping them by speaking up. Its difficult the know the speed of the class, so please communicate! 1.5 Endstate You have git configured on your computer; You have linked git to github; You have a repo cloned to your computer; You can push, pull, and merge git conflicts in the repository; You’ve learned the basics of using differential equations in R. 1.6 Instructors Introduction 1.6.1 MAJ Dusty Turner Army Combat Engineer Platoon Leader / XO / Company Commander Geospatial / Sapper / Route Clearance Hawaii / White Sands Missile Range / Iraq / Afghanistan Education West Point ’07 Operations Research, BS Missouri University of Science and Technology ’12 Engineering Management, MS THE Ohio State ’16 Integrated Systems Engineering, MS Applied Statistics, Graduate Minor Data Science R User Since ’14 Catch me on Twitter @dtdusty http://dustysturner.com/ 1.6.2 Robert Ward Education University of Chicago, ’13 Political Science &amp; English, BA Columbia University School of International and Public Affairs, ’18 Master of International Affairs, Specialization in Advanced Policy and Economic Analysis Data Science R user since 2011; also know some python and forgot some Stata Worked for Government Accountability Office Applied Research &amp; Methods Operations Research Systems Analyst at CAA and Army Leader Dashboard/Vantage PM team 1.7 Lets Get Started… 1.7.1 Prerequisite Packages install.packages(c(&quot;tidyverse&quot;, &quot;deSolve&quot;), dependencies = TRUE) "],
["2-introduction-to-git.html", "2 Introduction to git 2.1 Introduction 2.2 Prerequisites 2.3 Terminology: Git vs. Git Bash vs. GitHub/GitLab/BitBucket 2.4 Global Git Configuration 2.5 Generate an SSH (Secure SHell) Key 2.6 Add SSH Key to GitHub 2.7 Fork and Clone a Repository", " 2 Introduction to git 2.1 Introduction Our first step today will be to use Git to download the files for the tutorial from GitHub. Git is the world’s most widely used version control system. It is fast, flexible, and relatively easy to learn given its sophistication under the hood, making it an invaluable tool for collaborative software development. Moreover, access to Git and to services for using it collaboratively, such as GitLab, has grown substantially in the DoD in recent years, including on classified networks. Learning to use Git and related services will make you a more capable programmer, even if you primarily work alone or don’t think of yourself as doing “software development.” 2.2 Prerequisites Git installed on your computer GitHub account 2.3 Terminology: Git vs. Git Bash vs. GitHub/GitLab/BitBucket “Git” is a piece of software whose primary job is to track changes between different versions of text (and other) files, efficiently keep track of the entire history of those changes, and provide tools to merge different versions of files and “branches” of repositories (called “repos” for short). Git is a distributed version control system, meaning that the entire repo and its entire history are held simultaneously in every location where the repo is stored. You must install and run Git on your own computer to use it. “Git Bash” is a command-line application included with Git for Windows, which makes the bash shell - the default command-line shell for many Linux systems - available in Windows. “GitHub,” “GitLab,” “BitBucket,” and their competitors are websites that have built additional functionality around Git, primarily focused on helping people share Git repos. They provide a central location to and from which collaborators can sync any changes they’ve made to their shared repository. They also often include various project-management and Continuous Integration/Continuous Deployment (CI/CD) tools; these are not integral to Git, and we won’t be covering them today, but they can be very useful. Somewhat confusingly, GitHub also makes a piece of software called GitHub Desktop, which bundles Git itself with a graphical interface designed for use with GitHub specifically. We won’t be using this, and I prefer using Git on the command line, but it is one of many graphical Git clients that you might consider using. Today, we’ll be using a command-line tool (Git Bash on Windows, the built-in terminal if you’re on Mac or Linux), to run various git commands on our own computers, some of which will involve communicating with GitHub. 2.4 Global Git Configuration Before doing anything with Git, we need to set some global configuration variable. To do so, open Git Bash and run the following: git config --global user.name &quot;Your Name&quot; git config --global user.email your_email_here@host.com At this point, you could use Git for version control locally - for instance, these three commands will create a new folder, make it your working directory, then initialize a git repo there. mkdir sample_repo cd sample_repo git init 2.5 Generate an SSH (Secure SHell) Key However, Git is at its most powerful when used collaboratively through a platform like GitHub, so, next, we’ll set up GitHub to communicate securely with your local machine using the SSH protocol. Instead of the username/password or smart card authentication you may be used to, SSH typically involves public key authentication. In this setup, you generate a pair of keys, provide your public key to sites that you’d like to securely communicate with, and then let SSH do some cryptographic magic to use your private key to prove your identity without ever exposing it to anyone else. Before following along with this section, check to see if you already have a key pair saved in the default location: ls -la ~/.ssh/ If the output of this command includes a pair of files with the same name, one with the file extension “.pub” and the other without a file extension, you should probably skip the next section, particularly if the files have a standard name such as “id_rsa” or “id_ed25519.” If you don’t have a key pair, generate one by running the following line of code in Git Bash/Terminal. Use the same email address as your GitHub account. ssh-keygen -t ed25519 -C &quot;&lt;your_email_here@host.com&gt;&quot; You should see a response like the one below. If you don’t already have a key, just hit enter to use the suggested file path. Generating public/private ed25519 key pair. Enter file in which to save the key (/c/Users/robert.w.ward/.ssh/id_ed25519): You can then set a passphrase for your SSH key. This has no connection to your GitHub password or anything else - it’s an additional layer of security on the keypair itself, meant to ensure that nobody could impersonate you to GitHub even if they had your private key. You won’t see letters appear as you type, but you will have to type the same password twice. Good luck! Enter passphrase (empty for no passphrase): Enter same passphrase again: 2.6 Add SSH Key to GitHub You now need to copy the public key from the newly-generated pair so that you can upload it to GitHub. You have a couple of options here. To stick with the command line, you can use the cat command, plus the path to your key, to print it out in the terminal, and then copy it from there. Typically, copying from bash uses the rather unusual hotkey Ctrl+Ins, or you can right-click the highlighted text and click “Copy.” cat ~/.ssh/id_ed25519.pub You can also navigate to this file using your system’s file explorer - on Windows, you’ll find the .ssh folder in your user folder - and open it in a text editor. Now, navigate to GitHub’s SSH Key settings page. Click “New SSH Keys” in the top-right corner, paste in your public key, give it a title, and click “Add SSH Key.” You should now be able to communicate with GitHub via SSH! The process for GitLab, which tends to be the platform of choice for use on DoD networks due to its greater availability for self-hosting, is almost identical. Simply go to the settings page, choose “SSH Keys” from the menu bar on the left, and add a key on that page. 2.7 Fork and Clone a Repository Now, we can finally use Git to “clone” a repository found on GitHub to our local machines. First, however, we’ll “fork” the repository used to create this course website, which will create a copy of MAJ Turner’s GitHub project on your own account. To do this, go to the GitHub repository for this book and click the “Fork” button in the upper-right corner of the page. After a few seconds, this will take you to your new copy of the project. To clone this project to your computer, you’ll need the URL of the repository. Click on the green “Code” button, and with SSH selected (this should be the default), click the clipboard button to copy the repo URL. Finally, in Git Bash/Terminal, use cd to navigate to the folder in which you’d like to create the project folder, then run git clone on this URL. cd ~/projects/ git clone git@github.com:dusty-turner/etf-r-git-2020.git You should see output like the following: Cloning into &#39;etf-r-git-2020&#39;... Warning: Permanently added the RSA host key for IP address &#39;140.82.112.3&#39; to the list of known hosts. remote: Enumerating objects: 51, done. remote: Counting objects: 100% (51/51), done. remote: Compressing objects: 100% (43/43), done. remote: Total 51 (delta 8), reused 45 (delta 6), pack-reused 0 Receiving objects: 100% (51/51), 206.22 KiB | 17.18 MiB/s, done. Resolving deltas: 100% (8/8), done. This lets you know that the repo has been cloned - downloaded to your computer - successfully. Because we cloned it, it’s also linked to GitHub. However, this doesn’t mean that any work we do locally will automatically be synced to GitHub, or vice versa. Git asks us to be more intentional about tracking changes, requiring the user to choose which changes to track, when to “commit” these changes to the repo history, and when to “push” and “pull” new changes to and from GitHub. We’ll cover all of that later on. "],
["3-differential-equations-in-r.html", "3 Differential Equations in R 3.1 Introduction 3.2 deSolve 3.3 Real world example: SEIR 3.4 SEIR Differential Equations using deSolve in R 3.5 Solve Differential Equations 3.6 Explore Results", " 3 Differential Equations in R Disclaimer: All data shown in this example are notional, does not reflect any real world situations, and is used strictly for instructional purposes. 3.1 Introduction We take a quick pause from our git introduction to talk about differential equations in R. R is best known as a statistical coding language. However, it is often important to incorporate other tools into your workflow to support statistical modeling. 3.2 deSolve We will rely on the r package deSolve, an R wrapper to the FORTRAN ODE solver. install.packages(&quot;deSolve&quot;) library(deSolve) As always, we’ll also use tools from the tidyverse. install.packages(&quot;tidyverse&quot;) library(tidyverse) 3.2.1 Steps to solving differential equations with deSolve Define your first order differential equations Define parameters governing the differential equations Define initial conditions Define time step Solve differential equations 3.3 Real world example: SEIR In epidemiology, the SEIR equations model the spread of a disease through a population. The S, E, I, and R represent four distinct population bins: S: Susceptible E: Exposed I: Infected R: Removed A set of four differential equations govern a population’s movement through these four bins. \\(\\beta\\): Infectiousness rate - probability of transmitting disease from an infectious individual to a susceptible individual \\(\\sigma\\): 1 / time from exposure to infectiousness (i.e., time spent in “E” bin) \\(\\gamma\\): 1 / time from infectiousness to recovery (i.e., time spent in “I” bin) 3.4 SEIR Differential Equations using deSolve in R In order to solve a system of differential equations, we will work to provide all the elements of the lsoda() function from the deSolve library. sol &lt;- lsoda(y = init, times = t, func = seir_ode, parms = par) y: The initial values for the ODE syetem times: Times at which excplicit estimates for y are desired. func: R-function that computes the values of the derivatives in the ODE system (the model definition) at time t. parms: vector or list of parameters used in func 3.4.1 Define Initial Conditions iNot &lt;- 1/1000 # proportion of population that is infected on day 1 eNot &lt;- 1/100 # proportion of population that is exposed but not yet infected on day 1 rNot &lt;- 0 # proportion of population that is removed on day 1 sNot &lt;- 1 - iNot - eNot - rNot # proportion of population that is susceptible on day 1 init&lt;-c(sNot,eNot,iNot) 3.4.2 Define Time Steps t&lt;-seq(0,365) 3.4.3 Define the Ordinary Differential Equations seir_ode &lt;- function(t,Y,par){ S&lt;-Y[1] # Suseptible E&lt;-Y[2] # Exposed I&lt;-Y[3] # Infected beta&lt;-par[1] # this takes the first slot from the vector par that is passed in - it changes every time sigma&lt;-par[2] # this takes the second slot from the vector par that is passed in - it remains constant gamma&lt;-par[3] # this takes the third slot from the vector par that is passed in - it remains constant # mu&lt;-par[4] # this takes the third slot from the vector par that is passed in - it remains constant dYdt&lt;-vector(length=3) ## this creates an empty vector of length 3 dYdt[1]=-beta*I*S ## this is the formula for the suseptible population after the first step of the SEIR dYdt[2]=beta*I*S-sigma*E ## this is the formula for the exposed population after the first step of the SEIR dYdt[3]=sigma*E-gamma*I ## this is the formula for the infected population after the first step of the SEIR return(list(dYdt)) } 3.4.4 Define Parameters beta &lt;- 1/5 sigma &lt;- 1/6 gamma &lt;- 1/14 par&lt;-c(beta,sigma,gamma) 3.5 Solve Differential Equations 3.5.1 lsoda function sol &lt;- lsoda(y = init, times = t, func = seir_ode, parms = par) head(sol) ## time 1 2 3 ## [1,] 0 0.9890000 0.010000000 0.001000000 ## [2,] 1 0.9886557 0.008785122 0.002434822 ## [3,] 2 0.9880543 0.007993881 0.003610166 ## [4,] 3 0.9872404 0.007518909 0.004604707 ## [5,] 4 0.9862442 0.007284371 0.005474887 ## [6,] 5 0.9850863 0.007234498 0.006263121 We’ll return to this output in a second, but lets first take a deeper look at what is happening in lsoda(). 3.5.2 What is going on under the hood? sol &lt;- lsoda(y = init, times = t, func = seir_ode, parms = par, verbose = T) ## ## -------------------- ## Time settings ## -------------------- ## ## Normal computation of output values of y(t) at t = TOUT ## ## -------------------- ## Integration settings ## -------------------- ## ## Model function an R-function: ## Jacobian not specified ## ## ## -------------------- ## lsoda return code ## -------------------- ## ## return code (idid) = 2 ## Integration was successful. ## ## -------------------- ## INTEGER values ## -------------------- ## ## 1 The return code : 2 ## 2 The number of steps taken for the problem so far: 372 ## 3 The number of function evaluations for the problem so far: 745 ## 5 The method order last used (successfully): 2 ## 6 The order of the method to be attempted on the next step: 2 ## 7 If return flag =-4,-5: the largest component in error vector 0 ## 8 The length of the real work array actually required: 68 ## 9 The length of the integer work array actually required: 23 ## 14 The number of Jacobian evaluations and LU decompositions so far: 0 ## 15 The method indicator for the last succesful step, ## 1=adams (nonstiff), 2= bdf (stiff): 1 ## 16 The current method indicator to be attempted on the next step, ## 1=adams (nonstiff), 2= bdf (stiff): 1 ## ## -------------------- ## RSTATE values ## -------------------- ## ## 1 The step size in t last used (successfully): 1 ## 2 The step size to be attempted on the next step: 1 ## 3 The current value of the independent variable which the solver has reached: 365.7906 ## 4 Tolerance scale factor &gt; 1.0 computed when requesting too much accuracy: 0 ## 5 The value of t at the time of the last method switch, if any: 0 ## 3.5.3 How is deSolve doing the work? Let’s put in a few print() statements to help us learn. seir_ode_explore &lt;- function(t,Y,par){ print(str_c(&quot;S at time t = &quot;, t,&quot; is: &quot;, Y[1])) print(str_c(&quot;E at time t = &quot;, t,&quot; is: &quot;, Y[2])) print(str_c(&quot;I at time t = &quot;, t,&quot; is: &quot;, Y[3])) print(str_c(&quot;R at time t = &quot;, t,&quot; is: &quot;, Y[1]-Y[2]-Y[3])) S&lt;-Y[1] # Suseptible E&lt;-Y[2] # Exposed I&lt;-Y[3] # Infected beta&lt;-par[1] # this takes the first slot from the vector par that is passed in - it changes every time sigma&lt;-par[2] # this takes the second slot from the vector par that is passed in - it remains constant gamma&lt;-par[3] # this takes the third slot from the vector par that is passed in - it remains constant dYdt&lt;-vector(length=3) ## this creates an empty vector of length 3 dYdt[1]=-beta*I*S ## this is the formula for the suseptible population after the first step of the SEIR dYdt[2]=beta*I*S-sigma*E ## this is the formula for the exposed population after the first step of the SEIR dYdt[3]=sigma*E-gamma*I ## this is the formula for the infected population after the first step of the SEIR print(str_c(&quot;dSdt at time t = &quot;, t,&quot; is: &quot;, dYdt[1])) print(str_c(&quot;dEdt at time t = &quot;, t,&quot; is: &quot;, dYdt[2])) print(str_c(&quot;dIdt at time t = &quot;, t,&quot; is: &quot;, dYdt[3])) return(list(dYdt)) } Lets see what this teaches us. t&lt;-seq(0,1) sol_explore&lt;-lsoda(y = init, times = t, func = seir_ode_explore, parms = par, verbose = F) ## [1] &quot;S at time t = 0 is: 0.989&quot; ## [1] &quot;E at time t = 0 is: 0.01&quot; ## [1] &quot;I at time t = 0 is: 0.001&quot; ## [1] &quot;R at time t = 0 is: 0.978&quot; ## [1] &quot;dSdt at time t = 0 is: -0.0001978&quot; ## [1] &quot;dEdt at time t = 0 is: -0.00146886666666667&quot; ## [1] &quot;dIdt at time t = 0 is: 0.0015952380952381&quot; ## [1] &quot;S at time t = 0 is: 0.989&quot; ## [1] &quot;E at time t = 0 is: 0.01&quot; ## [1] &quot;I at time t = 0 is: 0.001&quot; ## [1] &quot;R at time t = 0 is: 0.978&quot; ## [1] &quot;dSdt at time t = 0 is: -0.0001978&quot; ## [1] &quot;dEdt at time t = 0 is: -0.00146886666666667&quot; ## [1] &quot;dIdt at time t = 0 is: 0.0015952380952381&quot; ## [1] &quot;S at time t = 0.000999998730151101 is: 0.988999802200251&quot; ## [1] &quot;E at time t = 0.000999998730151101 is: 0.00999853113519857&quot; ## [1] &quot;I at time t = 0.000999998730151101 is: 0.00100159523606953&quot; ## [1] &quot;R at time t = 0.000999998730151101 is: 0.977999675828983&quot; ## [1] &quot;dSdt at time t = 0.000999998730151101 is: -0.000198115498071495&quot; ## [1] &quot;dEdt at time t = 0.000999998730151101 is: -0.00146830635779493&quot; ## [1] &quot;dIdt at time t = 0.000999998730151101 is: 0.00159487933900432&quot; ## [1] &quot;S at time t = 0.000999998730151101 is: 0.988999801884754&quot; ## [1] &quot;E at time t = 0.000999998730151101 is: 0.00999853169550673&quot; ## [1] &quot;I at time t = 0.000999998730151101 is: 0.00100159487731375&quot; ## [1] &quot;R at time t = 0.000999998730151101 is: 0.977999675311933&quot; ## [1] &quot;dSdt at time t = 0.000999998730151101 is: -0.000198115427046416&quot; ## [1] &quot;dEdt at time t = 0.000999998730151101 is: -0.00146830652220471&quot; ## [1] &quot;dIdt at time t = 0.000999998730151101 is: 0.00159487945801443&quot; ## [1] &quot;S at time t = 0.0019999974603022 is: 0.988999603769649&quot; ## [1] &quot;E at time t = 0.0019999974603022 is: 0.00999706339068465&quot; ## [1] &quot;I at time t = 0.0019999974603022 is: 0.00100318975486552&quot; ## [1] &quot;R at time t = 0.0019999974603022 is: 0.977999350624099&quot; ## [1] &quot;dSdt at time t = 0.0019999974603022 is: -0.000198430854013554&quot; ## [1] &quot;dEdt at time t = 0.0019999974603022 is: -0.00146774637776722&quot; ## [1] &quot;dIdt at time t = 0.0019999974603022 is: 0.00159452082071895&quot; ## [1] &quot;S at time t = 0.0019999974603022 is: 0.988999603454222&quot; ## [1] &quot;E at time t = 0.0019999974603022 is: 0.00999706395082837&quot; ## [1] &quot;I at time t = 0.0019999974603022 is: 0.00100318939622868&quot; ## [1] &quot;R at time t = 0.0019999974603022 is: 0.977999350107165&quot; ## [1] &quot;dSdt at time t = 0.0019999974603022 is: -0.000198430783011928&quot; ## [1] &quot;dEdt at time t = 0.0019999974603022 is: -0.00146774654212613&quot; ## [1] &quot;dIdt at time t = 0.0019999974603022 is: 0.00159452093969316&quot; ## [1] &quot;S at time t = 0.301390173240588 is: 0.988926061825765&quot; ## [1] &quot;E at time t = 0.301390173240588 is: 0.00958273184812076&quot; ## [1] &quot;I at time t = 0.301390173240588 is: 0.00146450547918966&quot; ## [1] &quot;R at time t = 0.301390173240588 is: 0.977878824498455&quot; ## [1] &quot;dSdt at time t = 0.301390173240588 is: -0.000289657527211457&quot; ## [1] &quot;dEdt at time t = 0.301390173240588 is: -0.00130746444747534&quot; ## [1] &quot;dIdt at time t = 0.301390173240588 is: 0.00149251444045896&quot; ## [1] &quot;S at time t = 0.301390173240588 is: 0.988926539031796&quot; ## [1] &quot;E at time t = 0.301390173240588 is: 0.00958162849766193&quot; ## [1] &quot;I at time t = 0.301390173240588 is: 0.0014653034288995&quot; ## [1] &quot;R at time t = 0.301390173240588 is: 0.977879607105235&quot; ## [1] &quot;dSdt at time t = 0.301390173240588 is: -0.000289815489714602&quot; ## [1] &quot;dEdt at time t = 0.301390173240588 is: -0.00130712259322905&quot; ## [1] &quot;dIdt at time t = 0.301390173240588 is: 0.00149227355230798&quot; ## [1] &quot;S at time t = 0.600780349020873 is: 0.988826067633474&quot; ## [1] &quot;E at time t = 0.600780349020873 is: 0.00921438462475756&quot; ## [1] &quot;I at time t = 0.600780349020873 is: 0.00189673347862316&quot; ## [1] &quot;R at time t = 0.600780349020873 is: 0.977714949530094&quot; ## [1] &quot;dSdt at time t = 0.600780349020873 is: -0.000375107901403141&quot; ## [1] &quot;dEdt at time t = 0.600780349020873 is: -0.00116062286938979&quot; ## [1] &quot;dIdt at time t = 0.600780349020873 is: 0.00140024980803413&quot; ## [1] &quot;S at time t = 0.600780349020873 is: 0.988826979620112&quot; ## [1] &quot;E at time t = 0.600780349020873 is: 0.00921227029764615&quot; ## [1] &quot;I at time t = 0.600780349020873 is: 0.00189826390777727&quot; ## [1] &quot;R at time t = 0.600780349020873 is: 0.977716445414689&quot; ## [1] &quot;dSdt at time t = 0.600780349020873 is: -0.000375410913289854&quot; ## [1] &quot;dEdt at time t = 0.600780349020873 is: -0.00115996746965117&quot; ## [1] &quot;dIdt at time t = 0.600780349020873 is: 0.00139978810381408&quot; ## [1] &quot;S at time t = 0.900170524801159 is: 0.988701726706946&quot; ## [1] &quot;E at time t = 0.900170524801159 is: 0.00888711394228682&quot; ## [1] &quot;I at time t = 0.900170524801159 is: 0.00230343298203867&quot; ## [1] &quot;R at time t = 0.900170524801159 is: 0.977511179782621&quot; ## [1] &quot;dSdt at time t = 0.900170524801159 is: -0.000455481633339072&quot; ## [1] &quot;dEdt at time t = 0.900170524801159 is: -0.00102570402370873&quot; ## [1] &quot;dIdt at time t = 0.900170524801159 is: 0.00131665472975933&quot; ## [1] &quot;S at time t = 0.900170524801159 is: 0.988702553727926&quot; ## [1] &quot;E at time t = 0.900170524801159 is: 0.00888518412147013&quot; ## [1] &quot;I at time t = 0.900170524801159 is: 0.00230483294164379&quot; ## [1] &quot;R at time t = 0.900170524801159 is: 0.977512536664812&quot; ## [1] &quot;dSdt at time t = 0.900170524801159 is: -0.000455758843063893&quot; ## [1] &quot;dEdt at time t = 0.900170524801159 is: -0.00102510517718113&quot; ## [1] &quot;dIdt at time t = 0.900170524801159 is: 0.00131623309584189&quot; ## [1] &quot;S at time t = 1.51605042118312 is: 0.988373201062988&quot; ## [1] &quot;E at time t = 1.51605042118312 is: 0.00833402334892546&quot; ## [1] &quot;I at time t = 1.51605042118312 is: 0.00306636105684125&quot; ## [1] &quot;R at time t = 1.51605042118312 is: 0.976972816657221&quot; ## [1] &quot;dSdt at time t = 1.51605042118312 is: -0.000606141818673015&quot; ## [1] &quot;dEdt at time t = 1.51605042118312 is: -0.000782862072814562&quot; ## [1] &quot;dIdt at time t = 1.51605042118312 is: 0.0011699781017132&quot; ## [1] &quot;S at time t = 1.51605042118312 is: 0.988374175939042&quot; ## [1] &quot;E at time t = 1.51605042118312 is: 0.00833166910389482&quot; ## [1] &quot;I at time t = 1.51605042118312 is: 0.0030680885146263&quot; ## [1] &quot;R at time t = 1.51605042118312 is: 0.97697441832052&quot; ## [1] &quot;dSdt at time t = 1.51605042118312 is: -0.000606483891470362&quot; ## [1] &quot;dEdt at time t = 1.51605042118312 is: -0.000782127625845441&quot; ## [1] &quot;dIdt at time t = 1.51605042118312 is: 0.00116946233769964&quot; We can see from this output how lsoda is stepping through to numerically solve the differential equations. 3.6 Explore Results Results from sol &lt;- lsoda(). head(sol) ## time 1 2 3 ## [1,] 0 0.9890000 0.010000000 0.001000000 ## [2,] 1 0.9886557 0.008785122 0.002434822 ## [3,] 2 0.9880543 0.007993881 0.003610166 ## [4,] 3 0.9872404 0.007518909 0.004604707 ## [5,] 4 0.9862442 0.007284371 0.005474887 ## [6,] 5 0.9850863 0.007234498 0.006263121 3.6.1 “Tidy” the output This is confusing. Let’s clean it up. SEIR_Population &lt;- sol %&gt;% as.data.frame() %&gt;% as_tibble() %&gt;% janitor::clean_names() %&gt;% rename(S = x1, E = x2, I = x3) %&gt;% mutate(R = 1 - rowSums(.[2:4])) %&gt;% mutate(across(.cols = S:R, .fns = ~ . * 10000)) head(SEIR_Population) ## # A tibble: 6 x 5 ## time S E I R ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 9890 100 10 0 ## 2 1 9887. 87.9 24.3 1.24 ## 3 2 9881. 79.9 36.1 3.42 ## 4 3 9872. 75.2 46.0 6.36 ## 5 4 9862. 72.8 54.7 9.97 ## 6 5 9851. 72.3 62.6 14.2 3.6.2 Visualize Output SEIR_Population %&gt;% pivot_longer(cols = S:R, names_to = &quot;Bin&quot;, values_to = &quot;Population&quot;) %&gt;% ggplot(aes(x = time, y = Population, color = fct_relevel(Bin, &quot;S&quot;, &quot;E&quot;, &quot;I&quot;, &quot;R&quot;))) + geom_line() + labs(x= &quot;Time&quot;, y = &quot;Population&quot;, color = &quot;Bin&quot;) "],
["4-collaboration-using-git.html", "4 Collaboration Using Git 4.1 Collaboration 4.2 Example 4.3 Git Workflow Overview", " 4 Collaboration Using Git 4.1 Collaboration As much as time allows, we will demonstrate the following: Pushing file changes to the remote repository; Pulling file changes from the remote repository; Managing and merging conflicts; Branching. This chapter offers a brief description of this basic Git workflow. For more details, check out these sites: Simple Git Guide: a very basic but very easy to follow guide to Git. Official Git Documentation: This includes both the fairly practical and readable Pro Git book and the excruciatingly detailed, but occasionally necessary, Git Reference Manual. Atlassian Git site: Atlassian, maker of GitHub competitor BitBucket, has a helpful set of tutorials on their website. 4.2 Example From here on out, we will work from the following R Markdown file. example_code/example_markdown.rmd 4.3 Git Workflow Overview 4.3.1 Committing Git’s job is to track the changes made to your files over time. However, it doesn’t track every single incremental change - it tracks the net differences between the user’s “commits,” which are essentially snapshots of the state of your repository. You can revert your whole repository or just specific files to how they were at any previous commit at any time. Committing in Git is a two-step process: first you git add the files you’ve changed to the staging area, then you git commit those changes. For example, to add and commit all changed files since your last commit, you could use the following code: git add . git commit -m &quot;commit message here&quot; Before committing, it’s often very useful use git status, which will tell you: Which files have been changed; Which of these files have been “added” to the staging area, and which have not; Which files in your repository folder are not currently being tracked by git (because they have never been added and committed). git status Your output might look something like this, with added files at the top, then non-added changed files, then untracked files. 4.3.2 Pushing Once you’ve made one or more commits - hopefully with informative commit messages - you can push those changes to whatever Git server you’re using. Typically, you can simply use the command git push to push all new commits from your current branch to your default remote server. In some cases, you may need to specify the remote (here, “origin”) and branch (“master”) to push to. git push origin master 4.3.3 Pulling/Fetching To retrieve any changes that your collaborators have pushed to the remote server, and immediately merge them with the current state of your repository, use git pull. If you don’t want to merge in these changes yet, but you do want to know what’s available on the remote server, you can use git fetch to check for changes without integrating them into your working files. Like git push, these commands can be used alone to pull/fetch from the default remote on the current branch, or can be used with branch and remote names to operate on those specific parameters. 4.3.4 Merging If you’re working with collaborators, you will likely run into cases where your commits conflict with someone else’s, such as when you both modify the same file. By default, if you git pull commits that conflict with what you’ve already committed, one of two things might happen. First, if two people have modified the same text file, but they have modified completely different parts of the file, Git will likely keep both sets of changes and allow you to continue working. (Note: you might not want this, if these two sets of changes actually cause problems for each other!) Second, if the conflicting commits did make changes to the same lines of the same file, or made changes to files such as images that Git doesn’t parse in such a fine-grained way, you will be prompted to resolve the conflicts. You can do this in two ways. First, you can open the file with conflicts, find where they are, and make edits so that the file looks the way you want it to. Second, you can use git checkout to pick one of the two versions of the file to keep in its entirety. Here’s a link to a quick guide on the latter method. Either way, once you’ve got the file the way you want it, use git add to stage the changes. Once you’ve done this for all files with conflicts, use git merge --continue to finish merging, which will produce a new “merge commit” that resolves the conflicts. Throughout this process, git status will be your best friend. Run it whenever you’re uncertain about which files have conflicts, which ones you’ve resolved and added, and what to do when you’re done - I actually learned about using git merge --continue by reading the output of git status during a merge! 4.3.5 Branching As powerful as git merge is, a better approach to working in parallel on the same files, or to working on code currently being used in production, is to use branches. A “branch” is exactly what it sounds like: a separate line of commits that branches off of a commit in your repository. Every repository has a default branch, typically called main or master, but you can easily create additional branches to work on specific features, experiment with new models, or make other changes without interfering with the main version of your code. When you’re ready to bring the changes you’ve made on your feature branch back into the default branch, then you can merge the entire branch, using the same git merge tool discussed above, since merging two branches is effectively exactly the same as merging two commits. You can create and merge branches using command-line git with git branch and git merge, but sites like GitHub and GitLab also have tools to help you manage this process, and I would recommend using them. For instance, both sites have systems by which a user can request to merge one branch into another, and they allow for easy visibility over and discussion of the changes made in the branch. These features have different names and slightly different ways of working on different sites - for instance, GitHub calls them “Pull Requests” and GitLab calls them “Merge Requests” - so we won’t discuss the details of any particular site here, but they work similarly and are fairly intuitive. "]
]
